# 排序算法

## 冒泡排序

1. 总结

   > 先循环一趟，然后里面再循环一趟，但是到数组长度-外层次数-1结束。  因为每一次的内部循环，完成了一次把最大值移动到最后的功能。

2. 代码

   ```java
   private static void sort(int[] a) {
           //比较相邻的元素。如果第一个比第二个大，就交换它们两个；
           //对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
           //针对所有的元素重复以上的步骤，除了最后一个；
           //重复步骤1~3，直到排序完成。
           if (a.length <= 1) {
               System.out.println(Arrays.toString(a));
           }
           for (int j = 0; j < a.length; j++) {
               // 为什么要-j 是因为每一次移动都把最大的值 移动到了最后面  所以最后面的值就不用再参与比较了
               for (int i = 0; i < a.length - 1 - j; i++) {
                   int i1 = a[i];
                   int i2 = a[i + 1];
                   if (i1 > i2) {
                       a[i] = i2;
                       a[i + 1] = i1;
                   }
               }
           }
       }
   ```

   

## 选择排序

1. 总结

   > 1.先循环一次，拿到第一个元素
   >
   > 2.套个子循环，从后面的元素中找最小的元素下标 （也就是选择）
   >
   > 3.找到以后就交换元素

2. 代码

   ```java
   private static void sort(int[] a) {
           //int count = 0;
           //初始状态：无序区为R[1..n]，有序区为空；
           //第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。
           // 该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
           //n-1趟结束，数组有序化了。
           if (a.length <= 1) {
               System.out.println(Arrays.toString(a));
           }
           for (int j = 0; j < a.length; j++) {
               // 找到最小的
               int minIndex = j;
               // 后面的都是无序区，前面的是有序区 找到无序区最小的下标
               for (int i = j; i < a.length; i++) {
                   //count++;
                   if (a[i] < a[minIndex]) {
                       minIndex = i;
                   }
               }
               // 把当前的元素  和后面无序区最小的元素交换
               int tmp = a[minIndex];
               a[minIndex] = a[j];
               a[j] = tmp;
           }
           // System.out.println("循环" + count + "次");
       }
   ```

   